-- Normalize database to support many-to-many relationships between threads and customers
-- This migration:
-- 1. Adds company_id and domain_match columns to customers table
-- 2. Creates thread_participants junction table
-- 3. Updates thread_processing_stages constraints
-- 4. Backfills company_id by matching email domains to companies.domain_name
-- 5. Sets up RLS policies for thread_participants

-- Step 1: Update customers table - Add company_id and domain_match columns
DO $$
BEGIN
  -- Add company_id column if it doesn't exist
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'customers'
      AND column_name = 'company_id'
  ) THEN
    ALTER TABLE public.customers
    ADD COLUMN company_id UUID REFERENCES public.companies(company_id) ON DELETE SET NULL;
    
    RAISE NOTICE 'Added company_id column to customers table';
  ELSE
    RAISE NOTICE 'company_id column already exists in customers table';
  END IF;

  -- Add domain_match column if it doesn't exist
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'customers'
      AND column_name = 'domain_match'
  ) THEN
    ALTER TABLE public.customers
    ADD COLUMN domain_match TEXT;
    
    RAISE NOTICE 'Added domain_match column to customers table';
  ELSE
    RAISE NOTICE 'domain_match column already exists in customers table';
  END IF;
END $$;

-- Step 2: Create thread_participants junction table
CREATE TABLE IF NOT EXISTS public.thread_participants (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  thread_id TEXT NOT NULL REFERENCES public.threads(thread_id) ON DELETE CASCADE,
  customer_id UUID NOT NULL REFERENCES public.customers(customer_id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT thread_participants_thread_customer_unique UNIQUE (thread_id, customer_id)
);

-- Create indexes for thread_participants table
CREATE INDEX IF NOT EXISTS idx_thread_participants_thread_id ON public.thread_participants(thread_id);
CREATE INDEX IF NOT EXISTS idx_thread_participants_customer_id ON public.thread_participants(customer_id);

-- Step 3: Update thread_processing_stages constraints
DO $$
DECLARE
  updated_count INTEGER;
BEGIN
  -- Drop existing CHECK constraint on current_stage if it exists
  IF EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conrelid = 'public.thread_processing_stages'::regclass
      AND conname LIKE '%current_stage%'
      AND contype = 'c'
  ) THEN
    -- Find and drop the constraint
    ALTER TABLE public.thread_processing_stages
    DROP CONSTRAINT IF EXISTS thread_processing_stages_current_stage_check;
    
    RAISE NOTICE 'Dropped existing current_stage CHECK constraint';
  END IF;

  -- Migrate existing data to new state values
  -- Map old processing states to new states:
  -- 'pending', 'importing', 'preprocessing', 'cleaning', 'chunking' → 'imported'
  -- 'summarizing' → 'analyzing'
  UPDATE public.thread_processing_stages
  SET current_stage = CASE
    WHEN current_stage IN ('pending', 'importing', 'preprocessing', 'cleaning', 'chunking') THEN 'imported'
    WHEN current_stage = 'summarizing' THEN 'analyzing'
    ELSE current_stage  -- Keep 'completed' and 'failed' as-is
  END
  WHERE current_stage IN ('pending', 'importing', 'preprocessing', 'cleaning', 'chunking', 'summarizing');
  
  GET DIAGNOSTICS updated_count = ROW_COUNT;
  RAISE NOTICE 'Migrated % rows to new current_stage values', updated_count;

  -- Add new CHECK constraint with updated values (only after data migration)
  ALTER TABLE public.thread_processing_stages
  ADD CONSTRAINT thread_processing_stages_current_stage_check
  CHECK (current_stage IN ('imported', 'resolving_entities', 'analyzing', 'completed', 'failed'));
  
  RAISE NOTICE 'Added new current_stage CHECK constraint';
END $$;

-- Step 4: Data Backfill - Update customers.company_id by matching email domains
DO $$
DECLARE
  updated_count INTEGER;
  customer_record RECORD;
  matched_company_id UUID;
  extracted_domain TEXT;
BEGIN
  -- Loop through customers that don't have a company_id set
  FOR customer_record IN
    SELECT customer_id, email, user_id
    FROM public.customers
    WHERE company_id IS NULL
      AND email IS NOT NULL
      AND email != ''
      AND email LIKE '%@%'
  LOOP
    -- Extract domain from email (everything after @)
    extracted_domain := LOWER(SPLIT_PART(customer_record.email, '@', 2));
    
    -- Find matching company by domain_name within the same user_id
    SELECT company_id INTO matched_company_id
    FROM public.companies
    WHERE user_id = customer_record.user_id
      AND LOWER(domain_name) = extracted_domain
    LIMIT 1;
    
    -- Update customer if match found
    IF matched_company_id IS NOT NULL THEN
      UPDATE public.customers
      SET company_id = matched_company_id,
          domain_match = extracted_domain
      WHERE customer_id = customer_record.customer_id;
      
      updated_count := COALESCE(updated_count, 0) + 1;
    ELSE
      -- Store the domain even if no match found (for debugging)
      UPDATE public.customers
      SET domain_match = extracted_domain
      WHERE customer_id = customer_record.customer_id;
    END IF;
  END LOOP;
  
  RAISE NOTICE 'Backfilled company_id for % customers', COALESCE(updated_count, 0);
END $$;

-- Step 5: Enable Row Level Security for thread_participants
ALTER TABLE public.thread_participants ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for thread_participants
-- Policy: Users can view their own thread participants
CREATE POLICY "Users can view their own thread participants" ON public.thread_participants
  FOR SELECT
  USING (auth.uid() = user_id);

-- Policy: Users can insert their own thread participants
CREATE POLICY "Users can insert their own thread participants" ON public.thread_participants
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Policy: Users can update their own thread participants
CREATE POLICY "Users can update their own thread participants" ON public.thread_participants
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- Policy: Users can delete their own thread participants
CREATE POLICY "Users can delete their own thread participants" ON public.thread_participants
  FOR DELETE
  USING (auth.uid() = user_id);

-- Add comments for documentation
COMMENT ON TABLE public.thread_participants IS 
  'Junction table enabling many-to-many relationships between threads and customers. Allows a single email thread to be linked to multiple customers.';

COMMENT ON COLUMN public.customers.domain_match IS 
  'Stores the domain string extracted from the customer email, used for matching against companies.domain_name';

